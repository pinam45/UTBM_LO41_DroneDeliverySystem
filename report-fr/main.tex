\documentclass[article, backcover, french, nodocumentinfo]{upmethodology-document}
\include{packages}
\include{settings}

\begin{document}
	\upmdocumentsummary{}
	\upmdocumentauthors{}
	%\upmdocumentvalidators{}
	\upmdocumentinformedpeople{}
	\upmpublicationpage{}
	\thispagestyle{empty}
	\tableofcontents{}
	%\lstlistoflistings{}
	%\listoffigures{}
	\newpage{}
	\section*{Introduction}\addcontentsline{toc}{section}{Introduction}
		\paragraph*{}
			Dans le cadre de l'UV LO41, nous devions réaliser un simulateur de livraison
			par drone inspiré de celui que Amazon essaye de mettre en place. Afin de répondre à ce problème, nous avons commencé par analyser le
			problème grâce à un réseau de Petri, par la suite nous avons réfléchis sur l'implémentation
			du problème en nous posant des questions sur la communications entre les différents
			acteurs du système de livraison. Après cela, nous avons réalisé l'implémentation et
			 avons fini par une analyse des performances de notre programme.
	\section{Conception}
		\subsection{Réseau de Petri}
			\begin{figure}[H]
			  \centering
			  \includegraphics[width=\textwidth]{figures/petri_drones}
			  \caption{Réseau de Petri}
			  \label{fig:petrinet}
			\end{figure}
			Ce réseau de Petri décrit le problème vu du drone, pour les besoins de la
			simulation du réseau de Petri, on a placé 60 drones étant donné qu'il y a 3
			cas où le drone peut s'écraser. Mais dans la réalité, il n'y a qu'une très
			petite chance que le drone est un problème technique.

			Pour commencer à livrer un client, un drone et un paquet doivent être
			disponible, une fois le drone chargé, le drone s'envole pour livrer le
			client, on a alors trois choix disponibles, le drone peut s'écraser, le
			client peut accepter le paquet ou le refuser, dans le cas où il accepte/refuse le
			colis, le drone retourne vers le vaisseau mère, il peut également s'écraser
			durant ce vol.

			Dans le cas ou le drone s'écrase avec un colis, le client
			devient un client «pas livré» car son colis n'existe plus, si le drone
			retourne au vaisseau mère avec le colis, le colis est remis dans la liste
			des livraisons et le drone est de nouveau disponible.

			Enfin lorsque le drone est disponible, s'il n'a plus de batterie, il peut
			aller se charger.
		\subsection{Communication}
			\subsubsection{Threads}
				Dans cette implémentions il a été choisi d'utiliser des threads plutôt que des processus.
				Cela permet entre autre d'éviter la surcharge lié à l'utilisation des processus.
				De plus les threads partagent leur espace d'adressage, ce qui permet une communication
				plus efficace entre les différents acteurs du programme (clients, drones, vaisseau mère).
			\subsubsection{Files de messages}
				Les files de messages sont les éléments centraux de ce programme, en plus de permettre aux drones,
				clients et au vaisseau mère de communiquer entre eux. Elles assurent également la synchronisation entre
				les différents acteurs. Ainsi lorsqu'un drone à fini de se charger il va envoyer un message au vaisseau
				mère afin de le prévenir, le vaisseau mère va alors le considérer comme disponible et lui confier un paquet
				si les conditions sont réunis (paquet disponible, le drone peut porter le paquet\ldots).
			\subsubsection{Mutex}
				Les mutex sont ici la pour éviter des accès concurrents, ils permettent de protéger des ressources critiques,
				en effet, on ne protège que les variables qui sont changés par un thread et qui peuvent être lu par d'autres threads.

	\section{Réalisation}
		\subsection{Structures}
			Dans ce projet, nous avons utilisé des fonctions pour créer et supprimer toutes les structures de données.
			De plus les drones, les clients et le mothership ont une fonction permettant de lancer leur thread.
			\subsubsection{Mothership}
			Au début du programme le mothership détient la liste des paquets, des clients et des drones.
			Le mothership est le thread principal du programme, c'est lui qui va lancer la simulation et par la suite va s'occuper de
			la communication avec les drones, à la fin de la simulation, il va aussi notifier les clients que la livraison des paquets
			restant est impossible (plus de drones disponible capable de porter les paquets restant ou l'on a essayé de livrer le paquet 3 fois).
			\subsubsection{Drone}
			Le drones ont tous une autonomie, une charge maximum, un temps de recharge. Ils ont également un pointeur sur le client a livrer,
			et un pointeur sur le colis a livrer.
			Les drones vont communiquer avec le client et le vaisseau mère, ils préviennent le client lorsqu'ils arrivent à proximité pour que
			celui-ci sorte le colis. Pour ce qui est de la communication avec le vaisseau mère, ils vont prévenir le vaisseau mère lorsqu'ils sont:
			chargé, de retour au vaisseau, qu'ils ont réussi/raté la livraison.
			Enfin les drones peuvent également avoir une panne technique qui fait s'écraser le drone.
			\subsubsection{Client}
			Le client a comme attribut principal la distance qui le sépare au vaisseau mère. Le client écoute uniquement des messages,
			il se charge de sortir ou non (pour simuler des absences) sa cible pour que le drone puisse trouver le point d'atterissage.
			Il reçoit également son paquet du drone.
			\subsubsection{Package}
			La structure package représente le colis à livrer au client, elle possède un poids, une priorité et l'identifiant du client à qui livrer le colis.
			Les colis prioritaires sont livrés les premiers. Les colis peuvent être perdu dans le cas où le drone s'écrase en les transportant.
			\subsubsection{Listes}
			La liste est une liste doublement chaînée, permettant de stocker les informations des différents éléments du programme.
			Elle nous permet d'insérer la où l'on veut et notamment d'utiliser une insertion triée, ce qui permet de garder les paquets
			triés par priorité dans la liste, de ce fait le paquet le plus prioritaire sera livré en premier sauf s'il n'y a pas de drone
			capable de le livrer, dans le cas échéant, on essayera de livrer le paquet suivant s'il existe.
		\subsection{Interface utilisateur}
			\subsubsection{ConsoleControl}
				L'interface utilisateur est entièrement en console mais emprunte beaucoup aux interfaces graphiques, elle a été réalisée avec la librairie C, \textbf{ConsoleControl} développée par Maxime Pinard, membre du groupe du projet. Le projet utilise la version 0.2 de la librairie.
				\paragraph*{}
					Fonctionnalités principales:
					\begin{itemize}
						\item Obtention d'informations sur la console (largeur, hauteur\ldots)
						\item Positionnement du curseur
						\item Changement des couleurs d'arrière-plan et de premier plan
						\item Gestion des inputs
						\item Dessin géométrique (lignes, rectangle)
						\item Interface utilisateur:
							\begin{itemize}
								\item Menu
								\item Menu d'options
								\item Messages
							\end{itemize}
						\item \ldots
					\end{itemize}
				\paragraph*{}
					Avantages:
					\begin{itemize}
						\item Pas de dépendances
						\item Utilisé en sous module compilé en même temps que le projet
					\end{itemize}
				\paragraph*{}
					Pour plus d'informations, voir \href{https://github.com/pinam45/ConsoleControl}{la page Github de la librairie}.
			\subsubsection{Tableau de bord (dashboard)}
				\p{Lancement}
					Le dashboard est représenté par la structure \jclass{Dashboard}, pour faire fonctionner ce dernier il faut allouer et la structure a l'aide de la fonction \jfunc{dashboard\_constructor} et lancer la fonction \jfunc{dashboard\_launch} avec en paramètre la structure. Dans le projet le dashboard est lancer dans un thread qui lui est réservé.
				\p{Communication}
					Pour mettre a jour les information du dashboard un système de communication par file de messages est disponible, pour cela il suffit d'utiliser une structure \jclass{DashboardMessage} et la fonction \jfunc{dashboard\_sendMessage}. La structure \jclass{DashboardMessage} contient le type d'élément concerné (drone, paquet, client), sont identifiant (id) et son nouvel état.
				\p{États}
					\begin{figure}[H]
						\centering
						\includegraphics[width=\textwidth]{figures/UI1}
						\caption{Interface utilisateur: en cour d’exécution}
						\label{fig:UIrunning}
					\end{figure}
					Plusieurs états sont possible pour chaque type d'élément, exemples avec la figure \ref{fig:UIrunning}:
					\begin{itemize}
						\item Le paquet 000 a bien été livré
						\item Le paquet 001 est en vol
						\item Le paquet 002 est en attente d’être livré
						\item Le drone 000 est en vol vers le client
						\item Le drone 001 est en charge
						\item Le drone 005 est en attente (soit il attend qu'un paquet lui soit attribué soit il attend la fin de journée car les paquets restant sont trop lourd ou les clients trop loin pour lui)
						\item Le drone 007 est mort suite a un incident technique
						\item Le drone 009 est en vol vers le vaisseau mère après une livraison réussie
						\item Le client 000 est absent lors de sa livraison
						\item Le client 001 attend sa livraison
						\item Le client 002 a reçut tout ces paquets
						\item Le client 019 a sortit sa cible pour l'arrivée du drone
					\end{itemize}
					Tout au long de l’exécution du programme les différents acteurs du programme envoient des messages au dashboard pour prévenir de leur état jusqu’à la fin du programme ou chaque acteur est dans un état terminal comme visible sur la figure \ref{fig:UIend}.
					\begin{figure}[H]
						\centering
						\includegraphics[width=\textwidth]{figures/UI2}
						\caption{Interface utilisateur: fin d’exécution}
						\label{fig:UIend}
					\end{figure}
					Les états finaux sont:
					\begin{itemize}
						\item Pour les paquets: livraison réussit ou échouée
						\item Pour les drones: journée finit ou mort
						\item Pour les clients: finit avec ayant reçut tout ces paquets ou finit avec des paquets manquants (limite d'essai atteint ou détruit avec la mort d'un drone)
					\end{itemize}
				\p{Configuration}
					Le dashboard est configurable, tout les messages d'état et les couleurs sont changeables. De plus le dashboard s'adapte dynamiquement a la taille de la console qui peut être redimensionnée au cour de l’exécution. En fonction de la largeur de la consule les élément s’afficheront sur 3 ou 1 colonne.
	\section{Utilisation}
		\subsection{Compilation}
			\subsubsection{Configuration}
				\paragraph*{Flags utilisé (gcc)}
					\begin{itemize}
						\item Flags de version POSIX:
							\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
-D_POSIX_C_SOURCE=200112L\end{lstlisting}
							On définit \textit{\_POSIX\_C\_SOURCE} pour utiliser la version \textit{200112L} de la norme POSIX.
						\item Flags de warning:
							\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
-pedantic -pedantic-errors -Wall -Wcast-align -Wcast-qual -Wconversion -Wdisabled-optimization -Wdouble-promotion -Wextra -Wfloat-equal -Wformat -Winit-self -Winvalid-pch -Wlogical-op -Wmain -Wmissing-declarations -Wmissing-include-dirs -Wpointer-arith -Wredundant-decls -Wshadow -Wswitch-default -Wswitch-enum -Wundef -Wuninitialized -Wunreachable-code -Wwrite-strings\end{lstlisting}
							Pour plus d'information voir les \href{https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html}{options de warning gcc}.
					\end{itemize}
			\subsubsection{Makefile}
				Le \textit{Makefile} se charge de compiler d'abord la librairie \textit{ConsoleControl} puis de compiler le projet en liant cette dernière. Un \textit{Makefile} s'utilise avec le programme Make, pour plus d'informations sur Make voir \href{https://www.gnu.org/software/make/}{le site de gnu}.\\
				Le \textit{Makefile} se configure grâce aux variables définies dans les deux premières sections, la configuration de base fournie est celle pour un OS Linux standard utilisant les commandes du shell et gcc.
				\begin{upmcaution}
					Compiler en \textbf{debug} pour tester est déconseillé car le logeur et le dashboard vont s'afficher en même temps, rendant le tout illisible.
				\end{upmcaution}
				\p{Compilation}
					Plusieurs cibles sont définies:
					\begin{description}
						\item[help] Affiches les cibles définit et leur effet
						\item[silent] Cible par défaut, équivalent a \texttt{make --silent all}
						\item[all] Compile le projet
						\item[debug] Compile le projet en debug en activant le logeur
						\item[clean] Supprime tous les fichiers et dossiers générés par le \textit{Makefile}
					\end{description}
					Pour appeler une cible:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ make <cible>\end{lstlisting}
					Pour simplement compiler le projet:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ make\end{lstlisting}
					Pour supprimer tous les fichiers et dossiers générés par le \textit{Makefile}:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ make clean\end{lstlisting}
		\subsection{Exécution}
			\subsubsection{Paramètres}
				\paragraph*{}
					Les drones, paquets et clients utilisé par le programme sont changeables, ils sont décrit dans des fichiers au format \textit{csv}. Si aucun n'arguments n'est passé au programme a son exécution les fichier par défaut (\textit{packages1.csv}, \textit{drones1.csv}, \textit{clients1.csv}) seront utilisés.
				\paragraph*{}
					Pour lancer le programme avec les fichiers par défault:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ ./build/bin/UTBM_LO41_DroneDeliverySystem.elf\end{lstlisting}
					Pour lancer le programme avec des autres fichiers:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ ./build/bin/UTBM_LO41_DroneDeliverySystem.elf PACKAGES_FILE CLIENT_FILE DRONE_FILE\end{lstlisting}
				\paragraph*{}
					3 groupes de fichiers de configurations de test sont fournis:
					\begin{enumerate}
						\item \textit{packages1.csv}, \textit{drones1.csv}, \textit{clients1.csv}
						\item \textit{packages2.csv}, \textit{drones2.csv}, \textit{clients2.csv}
						\item \textit{packages3.csv}, \textit{drones3.csv}, \textit{clients3.csv}
					\end{enumerate}
			\subsubsection{Tests}
				On utilise l’outil de profilage Valgrind pour tester la présence de memory leaks.\\
				On exécute la commande:
				\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ valgrind --leak-check=yes ./build/bin/UTBM_LO41_DroneDeliverySystem.elf\end{lstlisting}
				Et on obtient:
				\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
==18446==
==18446== HEAP SUMMARY:
==18446==     in use at exit: 0 bytes in 0 blocks
==18446==   total heap usage: 9,553 allocs, 9,553 frees, 190,043 bytes allocated
==18446==
==18446== All heap blocks were freed -- no leaks are possible
==18446==
==18446== For counts of detected and suppressed errors, rerun with: -v
==18446== Use --track-origins=yes to see where uninitialised values come from
==18446== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\end{lstlisting}
				De plus en exécutant la commande:
				\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ valgrind --tool-massif ./build/bin/UTBM_LO41_DroneDeliverySystem.elf \end{lstlisting}

				Nous n'avons donc pas de memory leak durant l'exécution du programme
				\begin{figure}[H]
					\centering
					\includegraphics[width=\textwidth]{figures/memory}
					\caption{Utilisation de la ram au cours de l'exécution du programme}
					\label{fig:MemoryUsage}
				\end{figure}

				Le premier pic local correspond à l'ouverture des fichiers de configurations,
				et le deuxième pic local qui est le pic global correspond au lancement des threads (20,3KiB)
				On remarquera que plus de la moitié de la ram est utilisé par le système pour ouvrir les fichiers et pour lancer les threads.
				Cependant en utilisant des processus, une bonne partie de la ram utilisé aurait été dupliquée, ce qui aurait probablement augmenté la quantité total de
				ram utilisée.

	\section{Conclusion}
		Ce projet nous a permis d'approfondir nos connaissances sur la programmation système sous Linux, et de manière générale
		sous Unix grâce à l'utilisation de la norme POSIX qui nous permet d'avoir un programme plus multiplateforme et plus moderne
		dans la conception de l'API.

		Enfin, nous avons également eu l'occasion d'analyser notre projet après sa réalisation.
\end{document}
