\documentclass[article, backcover, french, nodocumentinfo]{upmethodology-document}
\include{packages}
\include{settings}

\newcommand{\TODO}[2][ ]{\todo[inline,color=green]{#2}}

\begin{document}
	\upmdocumentsummary{}
	\upmdocumentauthors{}
	%\upmdocumentvalidators{}
	\upmdocumentinformedpeople{}
	\upmpublicationpage{}
	\thispagestyle{empty}
	\tableofcontents{}
	%\lstlistoflistings{}
	%\listoffigures{}
	\newpage{}
	\section{Conception}
		\subsection{Réseau de Petri}
			\begin{figure}[H]
			  \centering
			  \includegraphics[width=\textwidth]{figures/petri_drones}
			  \caption{Réseau de Petri}
			  \label{fig:petrinet}
			\end{figure}
			Ce réseau de Petri décrit le problème vu du drone, pour les besoins de la
			simulation du réseau de Petri, on a placé 60 drones étant donné qu'il y a 3
			cas où le drone peut s'écraser. Mais dans la réalité, il n'y a qu'une très
			petite chance que le drone est un problème technique.

			Pour commencer à livrer un client, un drone et un paquet doivent être
			disponible, une fois le drone chargé, le drone s'envole pour livrer le
			client, on a alors trois choix disponibles, le drone peut s'écraser, le
			client peut accepter le paquet ou le refuser, dans le cas où il accepte/refuse le
			colis, le drone retourne vers le vaisseau mère, il peut également s'écraser
			durant ce vol.

			Dans le cas ou le drone s'écrase avec un colis, le client
			devient un client «pas livré» car son colis n'existe plus, si le drone
			retourne au vaisseau mère avec le colis, le colis est remis dans la liste
			des livraisons et le drone est de nouveau disponible.

			Enfin lorsque le drone est disponible, s'il n'a plus de batterie, il peut
			aller se charger.
		\subsection{Communication}
			\subsubsection{Threads et Mutex}
				\TODO{Threads mieux que Processus}
				\TODO{Mutex pour éviter accès concurrents, pas utilisés pour la synchronisation}
			\subsubsection{Files de messages}
				\TODO{Synchronisation + aspect messages de communication}
	\section{Réalisation}
		\subsection{Listes}
			\TODO{LinkedList, possibilité d'insertion triée pour colis par ordre de priorité\ldots}
		\subsection{Structures}
			\TODO{Fonction pour créé / alouer et supprimer / libérer, fonction pour lancer dans un thread\ldots}
			\subsubsection{Mothership}
			\subsubsection{Drone}
			\subsubsection{Client}
			\subsubsection{Package}
		\subsection{Interface utilisateur}
			\subsubsection{ConsoleControl}
				\TODO{lib pour faire des UI en console}
			\subsubsection{Tableau de bord (dashboard)}
				\TODO{Thread avec file de messages}
				\TODO{Affiche état de chaque acteur/élément du programme}
				\TODO{Configurable + expliquer config actuelle}
	\section{Utilisation}
		\subsection{Compilation}
			\subsubsection{Configuration}
				\TODO{pédantic}
				\TODO{Norme POSIX magique}
				\TODO{Prérequis: version min de gcc}
			\subsubsection{Makefile}
				Le \textit{Makefile} se charge de compiler d'abord la librairie \textit{ConsoleControl} puis de compiler le projet en liant cette dernière. Un \textit{Makefile} s'utilise avec le programme Make, pour plus d'informations sur Make voir \href{https://www.gnu.org/software/make/}{le site de gnu}.\\
				Le \textit{Makefile} se configure grace aux variables définies dans les deux premières sections, la configuration de base fournie est celle pour un OS Linux standard utilisant les commandes du shell et gcc.
				\begin{upmcaution}
					Compiler en \textbf{debug} pour tester est déconseillé car le logeur et le dashboard vont s'afficher en même temps, rendant le tout illisible.
				\end{upmcaution}
				\p{Compilation}
					Plusieurs cibles sont définies:
					\begin{description}
						\item[help] Affiches les cibles définit et leur effet
						\item[silent] Cible par défaut, équivalent a \texttt{make --silent all}
						\item[all] Compile le projet
						\item[debug] Compile le projet en debug en activant le logeur
						\item[clean] Supprime tous les fichiers et dossiers générés par le \textit{Makefile}
					\end{description}
					Pour appeler une cible:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ make <cible>\end{lstlisting}
					Pour simplement compiler le projet:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ make\end{lstlisting}
					Pour supprimer tous les fichiers et dossiers générés par le \textit{Makefile}:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ make clean\end{lstlisting}
		\subsection{Exécution}
			\subsubsection{Paramètres}
				\TODO{Fichiers de config a passer en paramètres}
				\TODO{Fichiers par défaut et de test fournis}
			\subsubsection{Tests}
				\TODO{Valgrind}
\end{document}
