\documentclass[article, backcover, french, nodocumentinfo]{upmethodology-document}
\include{packages}
\include{settings}

\newcommand{\TODO}[2][ ]{\todo[inline,color=green]{#2}}

\begin{document}
	\upmdocumentsummary{}
	\upmdocumentauthors{}
	%\upmdocumentvalidators{}
	\upmdocumentinformedpeople{}
	\upmpublicationpage{}
	\thispagestyle{empty}
	\tableofcontents{}
	%\lstlistoflistings{}
	%\listoffigures{}
	\newpage{}
	\section{Conception}
		\subsection{Réseau de Petri}
			\begin{figure}[H]
			  \centering
			  \includegraphics[width=\textwidth]{figures/petri_drones}
			  \caption{Réseau de Petri}
			  \label{fig:petrinet}
			\end{figure}
			Ce réseau de Petri décrit le problème vu du drone, pour les besoins de la
			simulation du réseau de Petri, on a placé 60 drones étant donné qu'il y a 3
			cas où le drone peut s'écraser. Mais dans la réalité, il n'y a qu'une très
			petite chance que le drone est un problème technique.

			Pour commencer à livrer un client, un drone et un paquet doivent être
			disponible, une fois le drone chargé, le drone s'envole pour livrer le
			client, on a alors trois choix disponibles, le drone peut s'écraser, le
			client peut accepter le paquet ou le refuser, dans le cas où il accepte/refuse le
			colis, le drone retourne vers le vaisseau mère, il peut également s'écraser
			durant ce vol.

			Dans le cas ou le drone s'écrase avec un colis, le client
			devient un client «pas livré» car son colis n'existe plus, si le drone
			retourne au vaisseau mère avec le colis, le colis est remis dans la liste
			des livraisons et le drone est de nouveau disponible.

			Enfin lorsque le drone est disponible, s'il n'a plus de batterie, il peut
			aller se charger.
		\subsection{Communication}
			\subsubsection{Threads}
				Dans cette implémentation il a été choisi d'utiliser des threads plutôt que des processus.
				Cela permet en autre d'éviter la surcharge lié à l'utilisation des processus.
				De plus les threads partagent leur espace d'adressage, ce qui permet une communication
				plus efficace entre les différents acteurs du programme (clients, drones, vaisseau mère)
			\subsubsection{Files de messages}
				Les files de messages sont les éléments centraux de ce programme, en plus de permettre aux drones,
				clients et au vaisseau mère de communiquer entre eux. Elles assurent également la synchronisation entre
				les différents acteurs. Ainsi lorsqu'un drone à fini de se charger il va envoyer un message au vaisseau
				mère afin de le prévenir, le vaisseau mère va alors le considérer comme disponible et lui confier un paquet
				si les conditions sont réunis (paquet disponible, le drone peut porter le paquet...)
			\subsubsection{Mutex}
				Les mutex sont ici la pour éviter des accès concurrents, ils permettent de protéger des ressources critiques,
				en effet, on ne protège que les variables qui sont changés par un thread et qui peuvent être lu par d'autres threads.

	\section{Réalisation}
		\subsection{Structures}
			Dans ce projet, nous avons utilisé des fonctions pour créer et supprimer toutes les structures de données.
			De plus les drones, les clients et le mothership ont une fonction permettant de lancer leur thread.
			\subsubsection{Mothership}
			Au début du programme le mothership détient la liste des paquets, des clients et des drones.
			Le mothership est le thread principal du programme, c'est lui qui va lancer la simulation et par la suite va s'occuper de
			la communication avec les drones, à la fin de la simulation, il va aussi notifier les clients que la livraison des paquets
			restant est impossible (plus de drones disponible capable de porter les paquets restant ou l'on a essayé de livrer le paquet 3 fois).
			\subsubsection{Drone}
			Le drones ont tous une autonomie, une charge maximum, un temps de recharge. Ils ont également un pointeur sur le client a livrer,
			et un pointeur sur le packet a livrer.
			Les drones vont communiquer avec le client et le vaisseau mère, ils previennent le client lorsqu'ils arrivent à proximité pour que
			celui-ci sorte le colis. Pour ce qui est de la communication avec le vaisseau mère, ils vont prévenir le vaisseau mère lorsqu'ils sont:
			chargé, de retour au vaisseau, qu'ils ont reussi/raté la livraison.
			Enfin les drones peuvent également avoir une panne technique qui fait s'écraser le drone.
			\subsubsection{Client}
			Le client a comme attribut princial la distance qui le sépare au vaisseau mère. Le client écoute uniquement des messages,
			il se charge de sortir ou non (pour simuler des absences) sa cible pour que le drone puisse trouver le point d'atterissage.
			Il reçoit également son paquet du drone.
			\subsubsection{Package}
			La structure package représente le colis à livrer au client, elle possède un poid, une priorité et l'identifiant du client à qui livrer le colis.
			Les colis prioritaires sont livrés les premiers. Les colis peuvent être perdu dans le cas où le drone s'écrase en les transportant.
			\subsubsection{Listes}
			La liste est une liste doublement chainé, permettant de stocker les informations des différents éléments du programme.
			Elle nous permet d'insérer la où l'on veut et notamment d'utiliser une insertion triée, ce qui permet de garder les paquets
			triés par priorité dans la liste, de ce fait le paquet le plus prioritaire sera livré en premier sauf s'il n'y a pas de drone
			capable de le livrer, dans le cas échéant, on essayera de livrer le paquet suivant s'il existe.
		\subsection{Interface utilisateur}
			\subsubsection{ConsoleControl}
				\TODO{lib pour faire des UI en console}
			\subsubsection{Tableau de bord (dashboard)}
				\TODO{Thread avec file de messages}
				\TODO{Affiche état de chaque acteur/élément du programme}
				\TODO{Configurable + expliquer config actuelle}
	\section{Utilisation}
		\subsection{Compilation}
			\subsubsection{Configuration}
				\TODO{pédantic}
				\TODO{Norme POSIX magique}
				\TODO{Prérequis: version min de gcc}
			\subsubsection{Makefile}
				Le \textit{Makefile} se charge de compiler d'abord la librairie \textit{ConsoleControl} puis de compiler le projet en liant cette dernière. Un \textit{Makefile} s'utilise avec le programme Make, pour plus d'informations sur Make voir \href{https://www.gnu.org/software/make/}{le site de gnu}.\\
				Le \textit{Makefile} se configure grace aux variables définies dans les deux premières sections, la configuration de base fournie est celle pour un OS Linux standard utilisant les commandes du shell et gcc.
				\begin{upmcaution}
					Compiler en \textbf{debug} pour tester est déconseillé car le logeur et le dashboard vont s'afficher en même temps, rendant le tout illisible.
				\end{upmcaution}
				\p{Compilation}
					Plusieurs cibles sont définies:
					\begin{description}
						\item[help] Affiches les cibles définit et leur effet
						\item[silent] Cible par défaut, équivalent a \texttt{make --silent all}
						\item[all] Compile le projet
						\item[debug] Compile le projet en debug en activant le logeur
						\item[clean] Supprime tous les fichiers et dossiers générés par le \textit{Makefile}
					\end{description}
					Pour appeler une cible:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ make <cible>\end{lstlisting}
					Pour simplement compiler le projet:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ make\end{lstlisting}
					Pour supprimer tous les fichiers et dossiers générés par le \textit{Makefile}:
					\begin{lstlisting}[breaklines=true,breakatwhitespace=true,breakindent=0pt,columns=fixed,keepspaces=true,frame=single,basicstyle=\footnotesize\sffamily]
$ make clean\end{lstlisting}
		\subsection{Exécution}
			\subsubsection{Paramètres}
				\TODO{Fichiers de config a passer en paramètres}
				\TODO{Fichiers par défaut et de test fournis}
			\subsubsection{Tests}
				\TODO{Valgrind}
\end{document}
